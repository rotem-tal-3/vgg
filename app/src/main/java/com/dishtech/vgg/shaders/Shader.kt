// WARNING
// This file was auto generated by parser.py
// Do not edit manually.
package com.dishtech.vgg.shaders

import android.graphics.Bitmap

interface Shader {
	val uniforms: Array<Uniform>
	val name: String
	var rawString: String
}

interface SpectrumShader : Shader {
	var spectrum: FloatArray
}

interface SchemeShader : Shader {
	var scheme: Bitmap
}

interface TimedShader : Shader {
	var iTime: Float
}

class bar(override val uniforms: Array<Uniform>) : SpectrumShader, SchemeShader {
	constructor(scheme: Bitmap, spectrum: FloatArray): this(arrayOf(Uniform("scheme", "sampler2D", scheme), Uniform("spectrum", "float[]", spectrum)))
	override val name = "bar"
	override var scheme get() = uniforms[0].value as Bitmap
		set(value) {
			uniforms[0].value = value
			ShaderManager.setValueForShader(name, uniforms[0].name, value)
		}
	override var spectrum get() = uniforms[1].value as FloatArray
		set(value) {
			uniforms[1].value = value
			ShaderManager.setValueForShader(name, uniforms[1].name, value)
		}
	override var rawString = """#version 310 es
#extension GL_EXT_texture_buffer : enable

precision mediump float;

uniform sampler2D scheme;
uniform float spectrum[7];

in vec2 texCoord;
out vec4 fragColor;

void main() {
    int index = int(texCoord.x * 6.9999);
    float spec = spectrum[index];
    vec3 black = vec3(0.0, 0.0, 0.0);
    vec3 col = texture(scheme, texCoord).rgb;
    fragColor = vec4(mix(col, black, step(texCoord.y, spec)), 1.0);
}"""
}

class cool(override val uniforms: Array<Uniform>) : Shader {
	constructor(uMyUniform: FloatArray): this(arrayOf(Uniform("uMyUniform", "vec4", uMyUniform)))
	override val name = "cool"
	var uMyUniform get() = uniforms[0].value
		set(value) {
			uniforms[0].value = value
			ShaderManager.setValueForShader(name, uniforms[0].name, value)
		}
	override var rawString = """#version 300 es

mat3 getRotZMat(float a){return mat3(cos(a),-sin(a),0.,sin(a),cos(a),0.,0.,0.,1.);}

float dstepf = 0.0;

in vec2 texCoord;
out vec4 fragColor;

uniform vec4 uMyUniform;

float map(vec3 p) {
    p.x += sin(p.z*1.8);
    p.y += cos(p.z*.2) * sin(p.x*.8);
    p *= getRotZMat(p.z*0.8+sin(p.x)+cos(p.y));
    p.xy = mod(p.xy, 0.3) - 0.15;
    dstepf += 0.003;
    return length(p.xy);
}

void main() {
    vec2 uv = (texCoord - uMyUniform.xy*.5)/uMyUniform.y;
    vec3 rd = normalize(vec3(uv, (1.-dot(uv, uv)*.5)*.5));
    vec3 ro = vec3(0, 0, texCoord.x*1.26), col = vec3(0), sp;
    float cs = cos( texCoord.x*0.375 ), si = sin( texCoord.x*0.375 );
    rd.xz = mat2(cs, si,-si, cs)*rd.xz;
    float t=0.06, layers=0., d=0., aD;
    float thD = 0.02;
    for(float i=0.; i<100.; i++)
    {
        if(layers>15. || col.x > 1. || t>5.6) break;
        sp = ro + rd*t;
        d = map(sp);
        aD = (thD-abs(d)*15./16.)/thD;
        if(aD>0.)
        {
            col += aD*aD*(3.-2.*aD)/(1. + t*t*0.25)*.2;
            layers++;
        }
        t += max(d*.7, thD*1.5) * dstepf;
    }
    col = max(col, 0.);
    col = mix(col, vec3(min(col.x*1.5, 1.), pow(col.x, 2.5), pow(col.x, 12.)),
    dot(sin(rd.yzx*8. + sin(rd.zxy*8.)), vec3(.1666))+0.4);
    col = mix(col, vec3(col.x*col.x*.85, col.x, col.x*col.x*0.3),
    dot(sin(rd.yzx*4. + sin(rd.zxy*4.)), vec3(.1666))+0.25);
    fragColor = vec4( clamp(col, 0., 1.), 1.0 );
}
"""
}

class fragment(override val uniforms: Array<Uniform>) : TimedShader {
	constructor(iTime: Float): this(arrayOf(Uniform("iTime", "float", iTime)))
	override val name = "fragment"
	override var iTime get() = uniforms[0].value as Float
		set(value) {
			uniforms[0].value = value
			ShaderManager.setValueForShader(name, uniforms[0].name, value)
		}
	override var rawString = """#version 300 es

precision mediump float;

uniform float iTime;

in vec2 texCoord;
out vec4 fragColor;

void main() {
    fragColor = vec4(cos(iTime) * texCoord.x, texCoord.y, sin(iTime), 1.0);
}"""
}

class heat(override val uniforms: Array<Uniform>) : TimedShader {
	constructor(iTime: Float): this(arrayOf(Uniform("iTime", "float", iTime)))
	override val name = "heat"
	override var iTime get() = uniforms[0].value as Float
		set(value) {
			uniforms[0].value = value
			ShaderManager.setValueForShader(name, uniforms[0].name, value)
		}
	override var rawString = """#version 300 es

out vec4 fragColor;
in vec2 texCoord;

uniform float iTime;

mat3 RotZ(float a){return mat3(cos(a),-sin(a),0.,sin(a),cos(a),0.,0.,0.,1.);}	
vec3 path(vec3 p)
{
    p *= RotZ(p.z * 0.1);
    p += sin(p.zxy * 0.5) * 0.5;
    p *= RotZ(p.z * 0.2);
    return sin(p.zxy * 0.2) * 2.;
}
float df(vec3 p)
{
    p += path(p);
    p *= RotZ(p.z * 0.1);
    return 1.1 - cos(p.z*1.5) * 0.2 - max(abs(p.x),abs(p.y)) + length(p.xy)*0.2;
}

vec3 nor( vec3 pos, float prec )
{
    vec3 eps = vec3( prec, 0., 0. );
    vec3 nor = vec3(
    df(pos+eps.xyy) - df(pos-eps.xyy),
    df(pos+eps.yxy) - df(pos-eps.yxy),
    df(pos+eps.yyx) - df(pos-eps.yyx) );
    return normalize(nor);
}

vec3 blackbody(float Temp)
{
    vec3 col = vec3(255.);
    col.x = 56100000. * pow(Temp,(-3. / 2.)) + 148.;
    col.y = 100.04 * log(Temp) - 623.6;
    if (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. / 2.)) + 184.;
    col.z = 194.18 * log(Temp) - 1448.6;
    col = clamp(col, 0., 255.)/255.;
    if (Temp < 1000.) col *= Temp/1000.;
    return col;
}

float SubDensity(vec3 surfPoint, float prec, float ms)
{
    vec3 n;
    float s = 0.;
    const int iter = 10;
    for (int i=0;i<iter;i++)
    {
        n = nor(surfPoint,prec);
        surfPoint = surfPoint - n * ms;
        s += df(surfPoint);
    }

    return 1.-s/(ms*float(iter)); }

float SubDensity(vec3 p, float s)
{
    vec3 n = nor(p,s); 							    return df(p - n * s);						}

void main()
{
    vec2 uv = texCoord;

    float time = iTime*1.2;

    vec3 ro = vec3(0,0, time*5.);
    ro -= path(ro);

    vec3 cv = ro + vec3(0,0,4);     cv -= path(cv);

    vec3 lp = ro;	
    vec3 cu = normalize(vec3(0,1,0));
    vec3 z = normalize(cv-ro);
    vec3 x = normalize(cross(cu,z));
    vec3 y = cross(z,x);
    vec3 rd = normalize(z + uv.x*x + uv.y*y);

    float s = 1., d = 0.;
    for (int i=0; i<30; i++)     {
        if (log(d/1e6)>0.) break;         d += df(ro+rd*d);
    }

    vec3 p = ro + rd * d;											    vec3 ld = normalize(lp-p); 										    vec3 n = nor(p, 0.1);											    vec3 refl = reflect(rd,n);										    float diff = clamp( dot( n, ld ), 0.0, 1.0 ); 					    float fre = pow( clamp( 1. + dot(n,rd),0.0,1.0), 4. ); 			    float spe = pow(clamp( dot( refl, ld ), 0.0, 1.0 ),16.);		    vec3 col = vec3(0.8,0.5,0.2);
    float sss = df(p - n*0.001)/0.01;								
    float sb = SubDensity(p, 0.01, 0.1);							    vec3 bb = blackbody(200. * sb);									    float sss2 = 0.8 - SubDensity(p, 3.); 							
    vec3 a = (diff + fre + bb * sss2 * .8 + col * sss * .2) * 0.35 + spe;
    vec3 b = col * sss;

    fragColor.rgb = mix(a, b, .8-exp(-0.01*d*d));
}

"""
}

class spiral(override val uniforms: Array<Uniform>) : Shader {
	constructor(uMyUniform: FloatArray, uTexture0: Bitmap, uTexture1: Bitmap): this(arrayOf(Uniform("uMyUniform", "vec4", uMyUniform), Uniform("uTexture0", "sampler2D", uTexture0), Uniform("uTexture1", "sampler2D", uTexture1)))
	override val name = "spiral"
	var uMyUniform get() = uniforms[0].value
		set(value) {
			uniforms[0].value = value
			ShaderManager.setValueForShader(name, uniforms[0].name, value)
		}
	var uTexture0 get() = uniforms[1].value
		set(value) {
			uniforms[1].value = value
			ShaderManager.setValueForShader(name, uniforms[1].name, value)
		}
	var uTexture1 get() = uniforms[2].value
		set(value) {
			uniforms[2].value = value
			ShaderManager.setValueForShader(name, uniforms[2].name, value)
		}
	override var rawString = """#version 300 es

uniform vec4 uMyUniform;

in vec2 texCoord;
out vec4 fragColor;
uniform sampler2D uTexture0;
uniform sampler2D uTexture1;

float time() { return uMyUniform.a; }
vec3 grey = vec3(0.21, 0.72, 0.07); vec2 mouse() { return texCoord; } 
mat2 r(float th) {  vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); } 
void animate(inout vec2 p) {
    p *= r(time()*0.1 + mouse().x);
    p.y += time()*0.3;
    p.x += 3.0*cos(time()*0.1);
}


vec2 orb(vec2 p) {
    animate(p);

    float s = 1.0;
    float m = 1.0;

            for(int i = 0; i < 3; i++) {
        p = -1.0 + 2.0*fract(0.5 - 0.5*p);
        p *= 2.3/max(dot(p, p), 0.4);

        s = min(s, abs(cos(p.x)));
        m = min(m, abs((p.y)));
    }

    return vec2(s, m);
}


vec3 bump(vec2 p, float e, float z) {
    vec2 r = vec2(e, 0.0); vec2 l = r.yx;
    vec3 g = vec3(orb(p + l).x - orb(p - l).x,
    orb(p + r).x - orb(p - r).x,
    z); 
    return normalize(g);
}

vec3 texbump(sampler2D s, vec2 p, float e) {
    vec2 r = vec2(e, 0.0); vec2 l = r.yx;
    float ce = dot(grey, texture(s, p).rgb);
    vec3 g = (grey*mat3(
    texture(s, p - r).rgb,
    texture(s, p - l).rgb,
    vec3(ce)) - ce)/e;

    return normalize(g);
}

vec3 render(vec2 p) {
    vec3 rd = normalize(vec3(p, 1.0));     vec3 sn = bump(p, 0.01, -0.7);
    vec3 col = vec3(0);

    vec2 ma = orb(p);

    float occ = ma.x;
    float tm = pow(ma.y, 10.0); 
    animate(p);

    sn = normalize(sn + 0.2*mix(texbump(uTexture1, p, 0.001), texbump(uTexture0, p, 0.01), tm));
        vec3 re = reflect(rd, sn);

        col += pow(clamp(dot(-rd, sn), 0.0, 1.0), 10.0);
    col += pow(clamp(dot(-rd, re), 0.0, 1.0), 32.0);

    col *= mix(texture(uTexture1, p).rgb, texture(uTexture0, p).rgb, tm);     col *= 3.0*occ; 
        p += vec2(1, 0);
    p = mod(p + 1.0, 2.0) - 1.0;
    float mask = smoothstep(0.7, 0.71, length(p));

    col += vec3(4.1, 4.2, 0.2)*pow(abs(occ), 8.0)*mask
    *smoothstep(-1.0, 1.0, cos(10.0*time() + 3.0*p.y));

    col += vec3(0.1, 5.0, 3.5)*pow(abs(occ), 9.0)*(1.0 - mask)
    *smoothstep(-1.0, 1.0, cos(5.0*time()));

    return col;
}

void main() {
    vec2 uv = texCoord;
    vec2 of = vec2(0.3);

        const float aa = 1.0;

    vec3 col = render(texCoord);
    for(float i = 0.0; i < aa - 1.0; i++) {
                vec2 p = texCoord + 2.0*(uv + of);
        col += render(p);
        of *= r(3.14159/8.0);
    }

    col /= aa;

        col = pow(col, vec3(1.0/2.2));
    fragColor = vec4(col, 1);
}"""
}

class startunnel(override val uniforms: Array<Uniform>) : TimedShader {
	constructor(iTime: Float): this(arrayOf(Uniform("iTime", "float", iTime)))
	override val name = "startunnel"
	override var iTime get() = uniforms[0].value as Float
		set(value) {
			uniforms[0].value = value
			ShaderManager.setValueForShader(name, uniforms[0].name, value)
		}
	override var rawString = """#version 300 es

uniform float iTime;

in vec2 texCoord;
out vec4 fragColor;

float pn( vec3 x ) {
    return -1.0+2.4*0.6;
}

vec2 path(float t)
{
    return vec2(cos(t*0.2), sin(t*0.2)) * 2.;
}

const mat3 mx = mat3(1,0,0,0,7,0,0,0,7);
const mat3 my = mat3(7,0,0,0,1,0,0,0,7);
const mat3 mz = mat3(7,0,0,0,7,0,0,0,1);

float func(vec3 p)
{
    p = fract(p/68.6) - .5;
    return min(min(abs(p.x), abs(p.y)), abs(p.z)) + 0.1;
}

vec3 effect(vec3 p)
{
    p *= mz * mx * my * sin(p.zxy);     return vec3(min(min(func(p*mx), func(p*my)), func(p*mz))/.6);
}

vec4 displacement(vec3 p)
{
    vec3 col = 1.-effect(p*0.8);
    col = clamp(col, -.5, 1.);
    float dist = dot(col,vec3(0.023));
    col = step(col, vec3(0.82));    return vec4(dist,col);
}

vec4 map(vec3 p)
{
    p.xy -= path(p.z);
    vec4 disp = displacement(sin(p.zxy*2.)*0.8);
    p += sin(p.zxy*.5)*1.5;
    float l = length(p.xy) - 4.;
    return vec4(max(-l + 0.09, l) - disp.x, disp.yzw);
}

vec3 nor(vec3 pos, float prec )
{
    vec3 eps = vec3( prec, 0., 0. );
    vec3 nor = vec3(
    map(pos+eps.xyy).x - map(pos-eps.xyy).x,
    map(pos+eps.yxy).x - map(pos-eps.yxy).x,
    map(pos+eps.yyx).x - map(pos-eps.yyx).x );
    return normalize(nor);
}


vec4 light(vec3 ro, vec3 rd, float d, vec3 lightpos, vec3 lc)
{
    vec3 p = ro + rd * d;

        vec3 n = nor(p, 0.1);

    vec3 lightdir = lightpos - p;
    float lightlen = length(lightpos - p);
    lightdir /= lightlen;

    float amb = 0.6;
    float diff = clamp( dot( n, lightdir ), 0.0, 1.0 );

    vec3 brdf = vec3(0);
    brdf += amb * vec3(0.2,0.5,0.3);     brdf += diff * 0.6;

    brdf = mix(brdf, map(p).yzw, 0.5);
    return vec4(brdf, lightlen);
}

vec3 stars(vec2 uv, vec3 rd, float d,vec2 g)
{
    float k = fract( cos(uv.y * 0.0001 + uv.x) * 90000.);
    float var = sin(pn(d*0.6+rd*182.14))*0.5+0.5;    vec3 col = vec3(mix(0., 1., var*pow(k, 200.)));    return col;
}

void main() {
    float time = iTime*1.;
    float cam_a = time; 
    float cam_e = 3.2;     float cam_d = 4.; 
    float maxd = 40.; 
    vec2 uv = texCoord;

    vec3 col = vec3(0.);

    vec3 ro = vec3(path(time),time);
    vec3 cv = vec3(path(time+0.1),time+0.1);

    vec3 cu=vec3(0,1,0);
    vec3 rov = normalize(cv-ro);
    vec3 u = normalize(cross(cu,rov));
    vec3 v = cross(rov,u);
    vec3 rd = normalize(rov + uv.x*u + uv.y*v);

    vec3 curve0 = vec3(0);
    vec3 curve1 = vec3(0);
    vec3 curve2 = vec3(0);
    float ao = 0.; 
    float st = 0.;
    float d = 0.;
    for(int i=0;i<250;i++)
    {
        if (st<0.025*log(d*d/st/1e5)||d>maxd) break;        st = map(ro+rd*d).x;
        d += st * 0.6;         ao++;

    }
    if (d < maxd) {
        vec4 li = light(ro, rd, d, ro, vec3(0));        col = li.xyz/(li.w*0.2);
        col = mix(vec3(1.-ao/100.), col, 0.5);        fragColor.rgb = mix(col, vec3(0), 1.0-exp(-0.003*d*d));
    } else {
        fragColor.rgb = stars(uv, rd, d, texCoord);    }

        vec2 q = texCoord;
    fragColor.rgb *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.25 ); 
}
"""
}

class tunnel(override val uniforms: Array<Uniform>) : SpectrumShader, SchemeShader, TimedShader {
	constructor(iTime: Float, iChannel0: Bitmap, iChannel1: Bitmap, spectrum: FloatArray, scheme: Bitmap, touchLoc: FloatArray): this(arrayOf(Uniform("iTime", "float", iTime), Uniform("iChannel0", "sampler2D", iChannel0), Uniform("iChannel1", "sampler2D", iChannel1), Uniform("spectrum", "float[]", spectrum), Uniform("scheme", "sampler2D", scheme), Uniform("touchLoc", "vec2", touchLoc)))
	override val name = "tunnel"
	override var iTime get() = uniforms[0].value as Float
		set(value) {
			uniforms[0].value = value
			ShaderManager.setValueForShader(name, uniforms[0].name, value)
		}
	var iChannel0 get() = uniforms[1].value
		set(value) {
			uniforms[1].value = value
			ShaderManager.setValueForShader(name, uniforms[1].name, value)
		}
	var iChannel1 get() = uniforms[2].value
		set(value) {
			uniforms[2].value = value
			ShaderManager.setValueForShader(name, uniforms[2].name, value)
		}
	override var spectrum get() = uniforms[3].value as FloatArray
		set(value) {
			uniforms[3].value = value
			ShaderManager.setValueForShader(name, uniforms[3].name, value)
		}
	override var scheme get() = uniforms[4].value as Bitmap
		set(value) {
			uniforms[4].value = value
			ShaderManager.setValueForShader(name, uniforms[4].name, value)
		}
	var touchLoc get() = uniforms[5].value
		set(value) {
			uniforms[5].value = value
			ShaderManager.setValueForShader(name, uniforms[5].name, value)
		}
	override var rawString = """#version 310 es
#extension GL_EXT_texture_buffer : enable

precision mediump float;

uniform float iTime;
uniform sampler2D iChannel0;
uniform sampler2D iChannel1;
uniform float spectrum[7];
uniform sampler2D scheme;
uniform vec2 touchLoc;

in vec2 texCoord;
out vec4 fragColor;

float tex(vec2 uv, float s)
{
    float col;
    float ntiles = 10.0;

        vec2 r = mod(uv * ntiles, 1.0) - vec2(0.5);
    col = 1.0 - dot(r, r);

        vec4 n = texture(iChannel1, floor(uv * ntiles) / ntiles);
    col *= mod(n.r * n.g * n.b * s + iTime * 0.1 + clamp(s, 0.0, 0.6), 1.0);
    return clamp(col, 0.0, 1.0);
}

void main() {
    vec2 uv = texCoord;
    vec2 uv1 = uv * 2.0 - 1.0;

        vec2 center = vec2(0.0, 0.0) +
    vec2(0.075*((touchLoc.x - 0.5) * 5.33 + 0.5 * sin(iTime*4.0)),
    0.05*((touchLoc.y - 0.5) * 8.0 + 0.5 * sin(iTime*0.01 + 1.7)));
    vec2 p = uv1 - center;
    float r = length(p);
    float a = atan(p.y, p.x) * 3.0 / 3.14;
    vec2 uv2= vec2(1.0 / r + iTime*0.25, a);

        float bass = (spectrum[1] + spectrum[2]) / 2.0;
    float mid = (spectrum[3] + spectrum[4]) / 2.0 ;
    float treble = (spectrum[5] + spectrum[6]) / 2.0;
    float sound = (treble + mid) / 2.0;
    sound = pow(sound, 1.5);

        vec3 c1 = texture(scheme, vec2(0.07, 0.1)).rgb;
    vec3 c2 = mix(texture(scheme, vec2(0.21, 0.1)).rgb, vec3(0.6, 0.6, 1.0),vec3(0.5 + 0.5 * sin(iTime*0.1)));
    vec3 c  = mix(c1, c2, r);
    vec3 coltunnel =  sound * c * tex(uv2, bass) + ( 0.15 * texture(iChannel0, uv2).rgb);
    vec3 colback   = vec3(0.05,0.05,0.05);

        fragColor = vec4(r * coltunnel + (1.0 - r) * colback, 1.0);
}
"""
}
